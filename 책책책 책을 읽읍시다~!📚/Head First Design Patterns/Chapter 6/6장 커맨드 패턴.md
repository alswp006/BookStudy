# 커맨드 패턴
- 메소드 호출을 캡슐화하여 캡슐화를 더 높은 수준으로 끌어올릴 수 있다.
- 메소드 호출을 캡슐화하면 계산 과정의 각 부분을 결정화할 수 있기에 계산하는 코드를 호출한 객체는 그 일이 어떤 식으로 처리되는지 신경쓸 필요가 없다.
- 커맨드 패턴을 쓰면 작업을 요청하는 쪽과 처리하는 쪽을 분리할 수 있다.
## 커맨드 패턴 소개
- 커맨드 패턴의 쉬운 이해를 위해 음식 주문 과정을 살펴보자.
### 음식 주문 과정
1. 고객이 종업원에게 주문을 한다.
2. 종원원이 주문을 카운터에 전달한다. 
3. 주방장이 음식을 준비한다.
### 메소드를 활용하여 알아보기
1. createOrder() -> 고객 주문
2. rakeOrder() -> 종업원이 주물을 받고 주문 처리를 준비하는 orderUp() 메소드를 호출한다.
3. orderUp() -> Order 객체에는 음식을 준비할 때 필요한 지시 사항들이 있다. Order 객체가 주방장에게 makeBurger()같은 메소드 호출로 행동을 지시한다.
4. makeBurger(), makeShake() -> 주방장은 Order로부터 전달받은 지시사항에 따라 음식을 준비한다.
### 위에서 각 등장 인물의 역할
- 주문서 : 주문 내용을 캡슐화한다,
  - 주문 내용을 요구하는 객체로 여기저기 전달될 수 있다.
  - 이 객체의 인터페이스에는 식사 준비 행동을 캡슐화한 orderUp() 메소드와 식사를 준비하는 객체의 레퍼런스가 들어있고 orderUp()은 유일한 메소드이다.
  - 내용이 캡슐화되어 있어 종업원은 메뉴 주문 내용, 누가 식사를 준비할지를 전혀 몰라도 된다.
- 종업원 : 주문을 받고 orderUp() 메소드를 호출한다.
  - 주문을 받고 카운터로 가서 orderUp() 메소드를 호출하면 된다.
  - 종ㅇ업원의 takeOrder() 메소드는 여러 주문서를 매개변수로 전달한다.
- 주방장 : 식사를 준비하는데 필요한 정보를 가진다.
  - 실제 식사를 준비하는 방법은 주방장만 알고 있다.
  - 종업원이 orderUp() 메소드를 호출하면 주방장이 주문을 받아 음식을 만들 때 필요한 메소드를 처리한다.
  - 주방장과 종업원은 완전히 분리되어있고 각자의 할 일만 한다.

# 팩토리 패턴
- 팩토리 패턴은 불필요한 의존성을 없애서 결합 문제를 해결한다.
## new
- new를 쓸 때마다 특정 구현을 사용하게 되는 것이 아닌가??
  - new를 사용하면 구상 클래스의 인스턴스가 만들어진다. 당연히 특정 구현을 사용한 것이다.
  - 앞에서 구상 클래스를 바탕으로 코딩하면 나중에 코드를 수정할 가능성이 커지고 유연성이 떨어진다고 했었다.
- new를 안 쓸 수는 없다. 변화하는 무언가 때문에 new를 조심해서 사용해야 한다.
- 인터페이스를 바탕으로 만들어진 코드는 어떤 클래스든 특정 인터페이스만 구현하면 사용할 수 있기 때문에 여러 변화에 대응이 가능하다.
- 반대로 구상 클래스를 많이 사용하면 새로운 구성 클래스가 추가될 때마다 코드를 고쳐야 하므로 수많은 문제가 생길 수 있다.
  - 즉, 변경에 닫혀있는 코드가 된다. 이는 새로운 구상 형식을 써서 다시 열 수 있게 만들어야 한다.
## 피자가게 예제
- 만약 피자가게를 운영한다고 생각하고 피자 종류에 따른 피자를 만드는 코드를 추가한다고 생각해보자
```java
Pizza orderPizza(String type){
  Pizza pizza;

  if (type.equals("cheese")){
    pizza = new CheesePizza();
  } else if (type.equals("greek")){
    pizza = new GreekPizza();
  } else if (type.equals("pepperoni")){
    pizza = new PepperoniPizza();
  }

  ...
}
```
- 위와 같은 코드가 있으면 피자 종류를 제외하고 추가할 때마다 코드를 찾아서 지워주고 추가해줘야 한다.
- 아 매소드에서 가장 문제가 되는 부분은 인스턴스를 만드는 구상 클래스를 선택하는 부분이다.
  - 이 부분 때문에 상황이 변하면 코드를 변경해야 한다.
- 이제 바뀌는 부분과 바뀌지 않는 부분을 묶어 캡슐화를 해야 한다.
### 객체 생성 팩토리
- 위의 객체 생성을 처리하는 클래스를 팩토리라고 부른다.
- SimplePizzaFactory클래스를 만들고 나면 orderPizza()메소드는 새로 만든 객체의 클라이언트가 된다.(피자가 필요할 때마다 공장에 피자를 만들달라고 요청함)
```java
pubilc class SimplePizzaFactory{
  pubilc Pizza createPizza(String type){
    Pizza pizza = null;

    if (type.equals("cheese")){
    pizza = new CheesePizza();
    } else if (type.equals("pepperoni")){
    pizza = new PepperoniPizza();
    } else if (type.equals("veggie")){
    pizza = new VeggiePizza();
    } 
  }
}
```
- 이렇게 캡슐화하면 문제를 다른 객체로 넘긴 것 같지만 이 클래스를 사용하는 클라이언트가 많을 때 유용하고 구현을 변경할 때 이 클래스 하나만 고치면 된다.
### 클라이언트 코드 수정
```java 
public class PizzaStore{
  SimplePizzaFactory factory;

  public PizzaStore(SimPizzaFactory factory){
    this.factory = factory;
  }

  public Pizza orderPizza(String type){
    Pizza pizza = factory.createPizza(type);
  }
}

```

## 간단한 팩토리 정의
- SimpleFactory는 디자인 패턴이라기보다는 프로그래밍에 자주 쓰이는 관용구에 가깝다.
- 팩토리에서 생산하는 제품인 각 피자는 Pizza 인터페이스를 구현해야하며 구상 클래스여야 한다.
  - 디자인 패턴에서 "인터페이스를 구현한다"라는 표현이 나온다고 "implements 키워드를 써서 자바 인터페이스를 구현하는 클래스를 만든다"라고 생각하면 안된다.
  - 일반적으로 어떤 상위형식의 구상 클래스는 그 상위 형식의 인터페이스를 구현하는 클래스라고 생각하면 된다.
## 다양한 팩토리 만들기
- 각 지역에 체인점을 내고 지역의 특성을 살린 다양한 피자를 만들어야 한다.
```java
NYPizzaFactory nyFactory = new NYPizzaFactory();
PizzaStore nyStore = new PizzaStore(nyFactory);
nyStore.orderPizza("Veggie");

ChicagoPizzaFactory chicagoFactory = new ChicagoPizzaFactory();
PizzaStore chicagoStore = new PizzaStore(chicagoFactory);
chicagoStore.orderPizza("Veggie");
```
- PizzaStore와 피자 제작 코드 전체를 하나로 묶어주는 프레임 워크를 만들어야 한다.
- createPizza()메소드를 PizzaStore에 다시 넣고 이 메소드를 추상메소드로 선언하여 지역별로 PizzaStore의 서브클래스를 만들면 지점의 스타일을 살릴 수 있다.
```java
public abstract class PizzaStore{
  public Pizza orderPizza(String type){
    Pizza pizza;
    pizza = createPizza(type); //PizzaStore에 있는 createPizza() 사용
  
    //피자의 행동들...
  }
  abstract Pizza createPizza(String type); //팩토리 객체 대신 이 메소드를 사용
}
```
- 각 피자는 createPizza()는 오버라이드하지만 orderPizza()는 그대로 사용한다. 정의한 내용을 고쳐쓸 수 없게 하려면 메소드를 final로 선언한다.
- orderPizza()에서 createPizza()를 호출하면 Pizza의 서브클래스 종류에 따라 만들어지는 피자의 종류가 달라진다. 즉, 피자의 종류는 어떤 서브클래스를 선택했느냐에따라 결정된다.
- 각 서브 클래스는 PizzaStore를 상속받아서 사용한다.
## 피자 주문하기
- 만약 조엘과 에단이 주문한다고 생각해보자
  1. 조엘과 에단 둘 다 PizzaStore 인스턴스를 확보해야 한다. 조엘은 시카고 피자, 에단은 뉴욕 피자 인스턴스를 만들어야 한다.
  2. PizzaStore가 만들어지면 각각 orderPizza()를 호출한다. 이 때 인자를 써서 원하는 메뉴를 알려줘야 한다.
  3. 피자를 만들 때 호출되는 createPizza()메소드는 각각의 서브클래스에 정의되어 있고 각 서브클래스는 지역 스타일의 피자 인스턴스를 만든다.
  4. orderPizza()메소드는 어떤 스타일의 피자가 만들어졌는지는 알지 못하고 작업만 실행한다.
- 코드로 알하보기
  ```java
    1. 피자 주문
    PizzaStore nyPizzaStore = new NYPizzaStore();
    2. 주문 받기
    nyPizzaStore.orderPizza("cheese");
    3. 피자 만들기
    Pizza pizza = createPizza("cheese");
    4. 마무리
    pizza.prepare();
    pizza.bake();
    ...
  ```
- 서브클래스는 생성자를 통해 피자의 정보를 알려준다. 만약 만드는 방법이 다른 서브클래스는 메소드를 오버라이드하여 사용한다.
## 팩토리 메소드 패턴
- 위 피자 프로그램은 생산자 클래스와 제품 클래스로 나눠진다.
- 생산자 클래스는 PizzaStore, NyPizzaStore, ChicagoPizzaStore이고 제품 클래스는 Pizza, NYStyleCheesePizza, ...등이 있다.
- 생산자 클래스와 제품 클래스는 병렬 계츨 구조로 볼 수 있다.

# 네트워크와 스레드
- 자바 프로그램에선 다른 시스템에 있는 프로그램과 접촉할 수도 있다.
- 저수준 네트워킹과 관련된 자잘한 내용은 java.net 라이브러리에 들어있는 클래스에서 처리해준다.
## 채팅 프로그램 개요
- 클라이언트는 서버에 대해 알아야하고 서버는 모든 클라이언트에 대해 알아야 한다.
- 작동 원리
  1. 클라이언트가 서버에 접속한다.
  2. 서버에서 접속을 허용하고 클라이언트를 수신인 목록에 추가한다.
  3. 다른 클라이언트가 서버에 접속한다.
  4. 클라이언트 A에서 채팅 서비스로 메시지를 보낸다.
  5. 서버에서 메시지를 모든 참가자들에게 보냅니다. (메시지를 보낸 사용자에게도 보냅니다.)
### 연결하기, 보내기, 받기
- 클라이언트를 작동하게 하려면 세 가지 방법이 필요하다.
1. 클라이언트와 서버 사이에서 초기 연결을 정립하는 방법
2. 서버로 메시지를 보내는 방법
3. 서버로부터 메시지를 받는 방법
- 이런 작업은 여러가지 저수준 작업이 필요한데 자바 API의 네트워킹 패키지는 이를 쉽게 만들어준다.
- 하지만 채팅 클라이언트는 동시에 두 가지 일을 처리해야 한다. (메시지를 보내면서 동시에 메시지를 받아야 함)
## 네트워크 소켓 만들기
- 다른 시스템에 연결하려면 소켓 연결이 필요하다.
- Socket(소켓)은 두 시스템 사이의 네트워크 연결을 나타내는 객체이다.
- 소켓 연결이란 두 시스템이 서로에 대한 정보가 있다는 것을 의미한다.
- 소켓 연결을 하려면 서버가 어디에 있는지(IP 주소), 어떤 포트에서 돌아가고 있는지(TCP 포트)를 알아야 한다.
- Socket으로부터 데이터를 읽으려면 BufferedReader를 사용하면 된다.
- Socket으로부터 데이터를 쓰려면 PrintWriter를 사용하면 된다.
### TCP 포트
- TCP 포트는 서버에 있는 특정 프로그램을 나타내는 16비트 숫자일 뿐이다.
- TCP 포트는 물리적인 장치를 꽂는게 아니라 용도에 따라 적정하게 쓰이는 숫자에 불과하다.
- 서버 프로그램을 만들 때는 그 프로그램을 실행시킬 때 사용할 포트 번호를 지정하기 위한 코드가 들어가야 한다.
- 0~1023의 포트 번호는 예약되어있기 떄문에 사용하지 않는 것이 좋다.(웹(HTTP) 서버, 메일 서버 등)
- 서버 프로그램을 회사 네트워크 내에서 돌릴 예정이라면 자신이 사용하고자 하는 포트를 이미 사용하고 있는지 물어보는 것이 좋다.
- 포트 하나에서 여러 프로그램이 돌아갈 수는 없다.(BindException)
## 스레드
- 채팅 프로그램은 사용자가 GUI를 건드리는 것은 방해하지 않으며 서버로부터 오는 메시지를 확인할 수 있어야만 한다.
- 즉, 새로운 스레드가 필요하다.
- 스레드는 별도의 실행 스레드를 지칭한다. 즉, 별도의 호출 스택을 의미한다.
### 멀티 스레딩
- 자바에서는 다중 스레딩 기능이 내장되어 있다.
- 자바에서 스레드 여러 개를 사용할 수 있지만 Thread 클래스는 한 개뿐이다.
  -> 새로운 실행 스레드를 만들 때는 Thread 클래스의 인스턴스를 만들어야 한다.
- 메인 스레드와 다른 스레드들은 JVM에서 관리한다.
- 호출 스택이 2개 이상 있으면 여러 스택이 아주 빠르게 번갈아가며 실행되어 동시에 실행되는 것처럼 보인다.
  1. JVM에서 main() 메소드를 호출한다.
  2. main()에서 새로운 스레드를 시작한다. 새로운 스레드가 시작될 때까지 메인 스레드는 일시적으로 멈춘다.
  3. JVM에서는 두 스레드가 종료될 때까지 새로운 스레드와 원래의 메인 스레드 사이를 왔다갔다한다.
- 모든 Thread에는 할 작업을 지정해줘야 한다. 새로운 스레드 스택에 집어넣을 메소드가 필요하다.
### 새로운 스레드를 시작하는 방법
1. Runnable 객체(스레드에서 할 작업)를 만든다.
2. Thread 객체(일꾼)를 만들고 그 객체에 Runnable 객체(작업)를 전달한다.
3. Thread 객체를 시작시킨다.
- Runnable 인터페이스는 public void run()메소드만 정의하고 있기 때문에 이를 오버라이딩하여 사용해야 한다.
- 스레드에서 할일을 만들려면 Runnable 인터페이스를 구현하여 run()메소드를 오버라이딩하여 사용한다.
### 스레드 스케쥴러
- 스레드 스케쥴러는 스레드의 실행의 시작, 실행 시간, 일시정지 후 위치 등을 결정한다.
- 자바 API에는 스케줄러를 호출할 수 있는 메소드가 없어서 스케줄러는 사용자가 마음대로 제어할 수 없다.
- 그리고 "스케줄러가 어떤 특별한 방식으로 작동할 것을 가정하고 프로그램을 만들면 안 된다."라는 규칙이 있다.
- 스레드의 순서를 보장해주지 않는다.
### 스레드 대기 상태
- 스레드에 순서를 주는 가장 좋은 방법 가운데 하나는 주기적으로 대기 상태에 넣어주는 것이다.
- Thread.sleep(인자)메소드를 사용하면 인지 밀리초 만큼 스레드는 대기 상태로 들어가게 된다.  이는 InterruptedException이 발생할 수도 있어 예외처리를 해주어야 한다.
- 대기 상태에서 벗어난 스레드는 항상 실행 가능한 상태가 된다.
- 하지만 지정된 시간이 지나 대기 상태를 벗어나도 무조건 현재 실행중인 상태가 되는 것은 아니다.
### 병행성 문제
- 스레드 두 개 이상이 하나의 객체 데이터에 접근하게 되면 병행성 문제가 생긴다.
- 동일한 객체의 게터 또는 세터 메소드를 호출하게될 수도 있다.
- 이에 대한 방지로 접근과 관련된 락이 필요하다.
- 한 스레드가 객체를 사용하면 락을 잠그고 열쇠를 자신이 가지고 있다가 다 사용하여 열쇠를 반납하면 다른 스레드가 이를 사용할 수 있다.
- 이는 synchronized라는 키워드를 메소드에 선언해주면 된다.
  - 모든 자바 객체에는 자물쇠가 있는데 이는 대부분 열려있다.
  - 객체에 동기화된 메소드가 있으면 자물쇠에 해당하는 열쇠가 있어야만 동기화된 메소드를 건드릴 수 있다.
  - 즉, 다른 스레드가 열쇠를 가지고 있지 않아야만 동기화된 메소드에 들어갈 수 있다
- 동기화된 메소드에는 어느정도 과부하나 병행성 제한으로 인한 문제가 있을 수 있기에 성농을 위해서 전부 다 동기화하는 방법은 사용하면 안된다.
### 갱신 내용 손실 문제
- 스레드가 실행 중 잠들게 되고 다른 스레드가 이에 대해 작업을 하게된다.
- 그리고 잠들어있던 스레드가 원래 작업중이던 곳으로 돌아가면 갱신 내용 손실 문제가 일어나게 된다.
### 스레드 교착 상태
- 스레드 두 개가 상대방이 필요로 하는 열쇠를 가지고 있는 경우를 스레드 교착 상태라고 한다.
- 자바에서는 이런 교착 상태를 처리할 수 있는 메커니즘이 없기 때문에 프로그래머가 잘 만드는 수밖에 없다.

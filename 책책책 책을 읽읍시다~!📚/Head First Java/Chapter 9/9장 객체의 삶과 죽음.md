# 객체의 삶과 죽음
- 객체는 태어나고 죽는다. 이 시기들은 우리가 결정한다.
- 하지만 그냥 내버려둬고 가비지 컬렉터가 다 쓴 객체를 제거해준다.
## 스택과 힙
- 스택 : 메소드 호출과 지역 변수가 사는 곳
- 힙 : 모든 객체가 사는 곳
- 변수가 사는 곳은 변수의 종류(인스턴스 변수, 지역 변수)에 따라 달라진다.
  - 지역 변수 : 메소드 내에서 선언된 변수
  - 인스턴스 변수 : 메소드 내에서 선언된 변수를 제외한 클래스 내에서 선언된 변수
- 매소드는 스택에 차곡차곡 쌓이며 맨 위의 메소드는 항상 그 스택에서 현재 실행중인 메소드이다.
- 지역 변수가 참조 변수인 경우에는 객체가 들어가는 것이 아니라 참조하는 값만 스택에 들어간다.
- 인스턴스 변수는 힙에(그 변수가 속하는 객체 안에) 존재한다.
- 인스턴스 변수가 참조 변수일 경우에도 객체를 참조하는 값만 힙에 존재한다.
## 생성자
- 객체 생성에서 new 키워드를 사용한 new Duck()라는 부분은 Duck의 생성자를 호출하는 것이다.
- 생성자는 객체를 생성할 때 실행되는 코드이다.
- 우리가 생성자를 만들지 않으면 컴파일러가 기본 생성자를 만든다.
- 생성자에 인자가 필요하다면 new Duck(인자)라는 형태로 초기화도 가능하다
- 하지만 이러한 인자가 필요한 생성자를 만들 떄에도 Duck 클래스를 쉽게 만들기 위해서는 인자가 없는 생성자를 꼭 만들어줘야 한다.
  -> 생성자 오버로딩을 이용하면 한 클래스에 두 개 이상의 생성자를 만들 수 있다.
### 생성자애 대한 주의사항
- 생성자는 어떤 클래스 유형에 대해 new를 쓸 때 실행되는 코드이다.
- 생성자명은 반드시 클래스 명과 같아야하며 리턴 유형은 없다.
- 클래스를 만들 때 생성자를 만들지 않으면 컴파일러에서 기본 생성자를 자동으로 추가해준다.
- 생성자 오버로딩으로 한 클래스에 두 개 이상의 생성자를 만들 수 있다.
### 객체의 일생에서 상위 클래스 생성자의 역할
- 하위 클래스의 객체가 생성될 때 계층 구조를 따라 올라가며 나오는 모든 상위 클래스의 생성자가 실행된다.
- 추상 클래스도 생성자가 있어서 구상 클래스의 객체를 만들면 그 생성자가 실행된다.
- 새로 만들어지는 Dog 객체는 Animal 객체이기도 하고 Object 객체이기도 하다.
  - Dog를 만들고 싶다면 그 안에 Animal과 Object도 만들어야 한다. 이런 모든 과정은 생성자 연쇄라는 과정을 통해 이뤄진다.
 - public class Animal{
     public Animal(){
       System.out.println("Animal");
     }
   }
   public class Dog extends Animal{
     System.out.println("Dog");
   }
   public class Main{
     public static void main(String[] args){
       Dog dog = new Dog();
     }
   }
=> Animal
   Dog
- 상위 클래스의 생성자는 super()로 호출하고 우리가 직접 호출하지 않으면 컴파일러가 알아서 처리해준다.
- 생성자에서 super()를 호출하면 상위 클래스 생성자가 스택 맨 위로 올라간다.
- super()를 호출하는 선언문은 모든 생성자의 첫 번째 선언문이어야 한다.
- super(인자) 형태를 통해 인자를 줘야하는 부모의 생성자에도 인자를 전달하여 실행할 수 있다.
- 같은 클래스에 있는 다른 생성자를 호출할 때는 this()를 사용하면 된다.
- this()도 반드시 생성자의 첫 번째 선언문이어야하며 super()와 함께 쓸 수 없다.
### 객체의 레퍼런스를 제거하는 세 가지 방법
1. 레퍼런스가 영원히 영역을 벗어난다.
  - 메소드 안에서 레퍼런스 변수가 선언되면 메소드를 벗어나면 제거됨 
2. 레퍼런스에 다른 객체를 대입한다.
3. 레퍼런스를 직접 null로 설정한다.
- 해당 객체를 참조하는 레퍼런스 변수가 없으면 제거된다.

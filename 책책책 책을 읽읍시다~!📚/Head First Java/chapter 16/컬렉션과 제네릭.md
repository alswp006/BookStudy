# 컬렉션과 제네릭
## 대표적인 Collections
- TreeSet : 원소들을 정렬된 상태로 유지하며 원소가 중복되어 들어가지 않게 해준다.
- HashMap : 원소들을 이름/값 쌍 형식으로 저장하고 접근할 수 있게 해준다.
- LinkenList : 컬렉션 중간에서 원소를 추가하거나 삭제하는 작업을 더 빠르게 처리할 수 있게 해주는 컬렉션이다.
- HashSet : 컬렉션에 중복된 원소가 들어가지 않도록 해주고 컬렉션 내에서 어떤 원소를 빠르게 찾을 수 있게 해준다.
- LinkedHashMap : 일반 HashMap과 거의 똑같지만 원소가 삽입된 순서를 그대로 유지시켜줄 수 있고 원소에 마지맞으로 접근했던 순서를 기억하도록 설정할 수 있다.
## 제네릭과 형 안정성
- 제네릭과 관련된 코드는 거의 컬렉션과 관련된 코드이다.
- 제네릭을 다른 방식으로 사용할 수도 있지만 제네릭에서 가장 중요한 점은 형 안정성을 갖춘 컬렉션을 만들 수 있다는 것이다.
### 제네릭 사용 방법
1. 제네릭을 쓰는 클래스의 인스턴스를 만드는 방법
   - new ArrayList<Song>();
2. 제네릭 유형의 변수를 선언하고 변수에 값을 대입하는 방법
   - List<Song> songList = new ArrayList<Song>();
3. 제네릭 유형을 인자로 받아들이는 메소드 선언 방법
   - void foo(List<Song> list)
     x.foo(songList)
- 흔히 제네릭에서 볼 수 있는 T는 "컬렉션에 저장하고 컬렉션에서 리턴할 원소의 유형"이라고 생각하면 된다.
- new ArrayList<Song>이라고 한다면 T를 사용하는 모든 메소드 및 변수 선언에서 T는 Song이 된다.
## 정렬
- 정렬에는 TreeSet이나 Collections.sort()를 사용할 수 있다.
- 목록이 항상 정렬되어 있을 필요가 없다면 TreeSet은 매번 새로원 원소가 들어올 때마다 정렬되기에 느려질 수도 있다.
- sort메소드는 Comparable 객체로 구성된 목록만 받아들일 수 있다.
  - sort를 새로운 객체가 들어있는 ArrayList<Song>같은 곳에서 사용하려면 Song클래스에서 Comparable 인터페이스를 구현해야 한다.
  - comparable 인터페이스는 compareTo()메소드 한 개만 구현하면 된다.
  - 두 Song객체를 비교할 때 어떤 기준으로 정렬할지 결정하고 그 기준에 맞춰서 compareTo()메소드를 구현해야 한다.
  - 만약 제목 순으로 정렬한다면 return title.compareTo(s.getTitle() 과 같은 형태로 compareTo()메소드에소 반환해주면 된다.
- 제네릭에서 확장(extends)한다는 것은 확장(extends) 또는 구현(implements)를 뜻한다.
### ComParator 사용법
- 목록에 있는 어떤 원소가 자신을 같은 유형의 다른 원소와 비교하는 방법은 compareTo()메소드를 이용하는 방법밖에 없다.
- Comparator는 비교하고자 하는 원소 유형과 별개이다. 즉, 그 자체가 별도의 클래스이므로 원하는 대로 만들 수 있다.
  - ArtistComparator, BPMComparator 등등
- sort()메소드에 Comparator 객체를 전달하면 정렬 순서가 원소의 compareTo()메소드가 아닌 Comparator에 의해 결정된다.
  - sort(List O)를 사용하면 compareTo()메소드에 의해 순서가 결정된다.
    - 따라서 매개변수의 원소는 Comparable 인터페이스를 구현한 클래스 유형이어야 한다.
  - sort(List O, Comparator c)를 호출했을 떄는 목록에 있는 원소의 compareTo()대신 Comparator의 compare()메소드가 호출된다
    - 즉, 매개변수의 원소는 Comparable 인터페이스를 구현하지 않은 클래스라도 괜찮다.
## List, Set, Map
- List : 인덱스 위치를 알고 있는 컬렉션
- Set : 중복을 허용하지 않는 컬렉션
- Map : 키-값 쌍을 사용하는 컬렉션

# 컬렉션과 제네릭
## 대표적인 Collections
- TreeSet : 원소들을 정렬된 상태로 유지하며 원소가 중복되어 들어가지 않게 해준다.
- HashMap : 원소들을 이름/값 쌍 형식으로 저장하고 접근할 수 있게 해준다.
- LinkenList : 컬렉션 중간에서 원소를 추가하거나 삭제하는 작업을 더 빠르게 처리할 수 있게 해주는 컬렉션이다.
- HashSet : 컬렉션에 중복된 원소가 들어가지 않도록 해주고 컬렉션 내에서 어떤 원소를 빠르게 찾을 수 있게 해준다.
- LinkedHashMap : 일반 HashMap과 거의 똑같지만 원소가 삽입된 순서를 그대로 유지시켜줄 수 있고 원소에 마지맞으로 접근했던 순서를 기억하도록 설정할 수 있다.
## 제네릭과 형 안정성
- 제네릭과 관련된 코드는 거의 컬렉션과 관련된 코드이다.
- 제네릭을 다른 방식으로 사용할 수도 있지만 제네릭에서 가장 중요한 점은 형 안정성을 갖춘 컬렉션을 만들 수 있다는 것이다.
### 제네릭 사용 방법
1. 제네릭을 쓰는 클래스의 인스턴스를 만드는 방법
   - new ArrayList<Song>();
2. 제네릭 유형의 변수를 선언하고 변수에 값을 대입하는 방법
   - List<Song> songList = new ArrayList<Song>();
3. 제네릭 유형을 인자로 받아들이는 메소드 선언 방법
   - void foo(List<Song> list)
     x.foo(songList)
- 흔히 제네릭에서 볼 수 있는 T는 "컬렉션에 저장하고 컬렉션에서 리턴할 원소의 유형"이라고 생각하면 된다.
- new ArrayList<Song>이라고 한다면 T를 사용하는 모든 메소드 및 변수 선언에서 T는 Song이 된다.
## 정렬
- 정렬에는 TreeSet이나 Collections.sort()를 사용할 수 있다.
- 목록이 항상 정렬되어 있을 필요가 없다면 TreeSet은 매번 새로원 원소가 들어올 때마다 정렬되기에 느려질 수도 있다.
- sort메소드는 Comparable 객체로 구성된 목록만 받아들일 수 있다.
  - sort를 새로운 객체가 들어있는 ArrayList<Song>같은 곳에서 사용하려면 Song클래스에서 Comparable 인터페이스를 구현해야 한다.
  - comparable 인터페이스는 compareTo()메소드 한 개만 구현하면 된다.
  - 두 Song객체를 비교할 때 어떤 기준으로 정렬할지 결정하고 그 기준에 맞춰서 compareTo()메소드를 구현해야 한다.
  - 만약 제목 순으로 정렬한다면 return title.compareTo(s.getTitle() 과 같은 형태로 compareTo()메소드에소 반환해주면 된다.
- 제네릭에서 확장(extends)한다는 것은 확장(extends) 또는 구현(implements)를 뜻한다.
### ComParator 사용법
- 목록에 있는 어떤 원소가 자신을 같은 유형의 다른 원소와 비교하는 방법은 compareTo()메소드를 이용하는 방법밖에 없다.
- Comparator는 비교하고자 하는 원소 유형과 별개이다. 즉, 그 자체가 별도의 클래스이므로 원하는 대로 만들 수 있다.
  - ArtistComparator, BPMComparator 등등
- sort()메소드에 Comparator 객체를 전달하면 정렬 순서가 원소의 compareTo()메소드가 아닌 Comparator에 의해 결정된다.
  - sort(List O)를 사용하면 compareTo()메소드에 의해 순서가 결정된다.
    - 따라서 매개변수의 원소는 Comparable 인터페이스를 구현한 클래스 유형이어야 한다.
  - sort(List O, Comparator c)를 호출했을 떄는 목록에 있는 원소의 compareTo()대신 Comparator의 compare()메소드가 호출된다
    - 즉, 매개변수의 원소는 Comparable 인터페이스를 구현하지 않은 클래스라도 괜찮다.
## List, Set, Map
- List : 인덱스 위치를 알고 있는 컬렉션
- Set : 중복을 허용하지 않는 컬렉션
- Map : 키-값 쌍을 사용하는 컬렉션
  - 맵에 있는 각 원소는 두 객체이다.
  - 값은 중복될 수 있지만 키는 중복될 수 없다.
## Set에서 객체들에 대한 중복 확인법
- HashSet에서는 해시코드가 다르면 같은 객체로 간주하지 않습니다.
- 따라서 같은지 확인하려는 객체들은 같은 해시코드를 가질 수 있도록 hashCode()를 오버라이드해야 합니다.
- 하지만 해시코드가 같아도 두 객체가 같지 않을 수 있기 때문에 HashSet에서는 같은 해시코드를 가지는 두 객체에 대해 equals()메소드를 통해 두 객체가 정말 같은지를 판별합니다.
- 이렇게 HashCode()와 equals()메소드를 적절하게 오버라이드 했을 때 두 객체가 같은 것으로 나온다면 HashSet에서는 추가하려는 객체가 중복되었다고 생각하고 새 객체를 추가하지 않습니다.
### HashCode()와 equals()와 관련된 규칙
- API 문서의 Object 클래스에서 나타난 규칙은 다음과 같습니다.
    - 두 객체가 같으면 반드시 같은 해시코드를 가져야 한다.
    - 두 객체가 같으면 equals()메소드를 호출했을 때 true를 리턴해야 한다.
    - 두 객체의 해시코드 값이 같다고 반드시 객체가 같은 것은 아니지만 두 객체가 같으면 두 해시코드는 반드시 같아야 한다.
    - equals()를 오버라이드하면 반드시 hashCode()도 오버라이드해야한다.
    - hashCode()는 힙에 있는 각 객체마다 서로 다른 값을 가지는 유일한 정수를 리턴하기에 오버라이드하지 않으면 두 객체가 같은 것으로 간주될 수 없다.
    - equals()메소드는 기본적으로 “==”연산자를 써서 객체를 비교(레퍼런스가 참조하는 객체가 같은지)하기 때문에 오버라이드를 하지않으면 두 객체가 같은 것으로 간주될 수 없다.
    - a.equals(b)==true 이면 a.hashCode() == a.hashCode()이다.
    - a.hashCode() == a.hashCode()이라도 a.equals(b)==true는 아닐수도 있다.
## 다시 제네릭
- 어떤 메소드 인자가 Animal배열이면 어떤 Animal 하위유형의 배열이든 인자로 사용할 수 있다.
- void foo(Animal[] a){}으로 선언되어 있다면 foo(aDogArray)로도 사용가능하다.
- 하지만 ArrayList<Animal>에 ArrayList<Dog>는 전달하지 못한다.
  - Cat이 Dog 목록에 들어갈 수도 있기 때문에 컴파일러가 막음
- 배열 유형은 실행 중에도 다시 확인하지만 컬렉션 유형은 컴파일 중에만 확인한다.
### 와일드 카드
- 하지만 Animal의 하위 유형으로 구성된 ArrayList를 받아들일 수 있는 메소드 인자를 만들 수 있는 방법이 있다.
- 바로 와일드 카드를 쓰는 것이다.
- public void takeAnimals(ArrayList<? extends Animal> animals))
- 선언할 때 <?> 와일드카드를 사용하면 컴파일러에서 목록에 추가하는 작업을 전혀 허용하지 않는다.
- 메소드 인자에서 와일드카드를 사용하면 메소드 매개변수에 의해 참조되는 목록에 손상이 갈 만한 작업을 할 수 없다, -> 컴파일러가 막는다.
- 목록 원소를 가지고 작업은 할 수 있지만 새로운 것을 추가할 수는 없다.

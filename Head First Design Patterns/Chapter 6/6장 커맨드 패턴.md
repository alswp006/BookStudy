# 커맨드 패턴
- 메소드 호출을 캡슐화하여 캡슐화를 더 높은 수준으로 끌어올릴 수 있다.
- 메소드 호출을 캡슐화하면 계산 과정의 각 부분을 결정화할 수 있기에 계산하는 코드를 호출한 객체는 그 일이 어떤 식으로 처리되는지 신경쓸 필요가 없다.
- 커맨드 패턴을 쓰면 작업을 요청하는 쪽과 처리하는 쪽을 분리할 수 있다.
## 커맨드 패턴 소개
- 커맨드 패턴의 쉬운 이해를 위해 음식 주문 과정을 살펴보자.
### 음식 주문 과정
1. 고객이 종업원에게 주문을 한다.
2. 종원원이 주문을 카운터에 전달한다. 
3. 주방장이 음식을 준비한다.
### 메소드를 활용하여 알아보기
1. createOrder() -> 고객 주문
2. rakeOrder() -> 종업원이 주물을 받고 주문 처리를 준비하는 orderUp() 메소드를 호출한다.
3. orderUp() -> Order 객체에는 음식을 준비할 때 필요한 지시 사항들이 있다. Order 객체가 주방장에게 makeBurger()같은 메소드 호출로 행동을 지시한다.
4. makeBurger(), makeShake() -> 주방장은 Order로부터 전달받은 지시사항에 따라 음식을 준비한다.
### 위에서 각 등장 인물의 역할
- 주문서 : 주문 내용을 캡슐화한다,
  - 주문 내용을 요구하는 객체로 여기저기 전달될 수 있다.
  - 이 객체의 인터페이스에는 식사 준비 행동을 캡슐화한 orderUp() 메소드와 식사를 준비하는 객체의 레퍼런스가 들어있고 orderUp()은 유일한 메소드이다.
  - 내용이 캡슐화되어 있어 종업원은 메뉴 주문 내용, 누가 식사를 준비할지를 전혀 몰라도 된다.
- 종업원 : 주문을 받고 orderUp() 메소드를 호출한다.
  - 주문을 받고 카운터로 가서 orderUp() 메소드를 호출하면 된다.
  - 종ㅇ업원의 takeOrder() 메소드는 여러 주문서를 매개변수로 전달한다.
- 주방장 : 식사를 준비하는데 필요한 정보를 가진다.
  - 실제 식사를 준비하는 방법은 주방장만 알고 있다.
  - 종업원이 orderUp() 메소드를 호출하면 주방장이 주문을 받아 음식을 만들 때 필요한 메소드를 처리한다.
  - 주방장과 종업원은 완전히 분리되어있고 각자의 할 일만 한다.
- 이 객체 마을 식당은 어떤 것을 요구하는 객체와 그 요구를 받아들이고 처리하는 객체를 분리하는 객체 지향 디자인 패턴의 한 모델이라고 볼 수 있다.
### 커맨드 패턴 다이어그램
1. createCommandObject()
   - 클라이언트는 커맨드 객체를 생성해야한다.
   - 커맨드 객체는 리시버에 전달할 일련의 행동으로 구성된다.
2. receiver
   - 커맨드 객체에는 receiver의 정보가 같이 들어있다.
3. execute()
   - 커맨드 객체에서 제공하는 메소드는 execute() 하나 뿐이다.
   - 이 메소드는 행동을 캡슐화하여 receiver에 있는 특정 행동을 처리한다.
4. setCommand()
   - 클라이언트는 인보커(Invoker) 객체의 setCommand()메소드를 호출하는데 이 때 커맨드 객체를 넘겨준다.
   - 그 커맨드 객체는 나중에 쓰이기 전까지 인보커 객체에 보관된다.
5. execute()
   - 인보커에서 커맨드 객체의 execute() 메소드를 호출하면 receiver에 있는 행동 메소드가 호출된다.
6. receiver
   - action1()
   - action2() ...
#### 인보커 로딩
1. 클라이언트에서 커맨드 객체 생성
2. setCommand()를 호출해서 인보커에 커맨드 객체를 저장
3. 나중에 클라이언트에서 인보커에게 그 명령을 실행하라고 요청
- 일단 어떤 명령을 인보커에 로딩한 다음 한번만 작업을 처리하고 커맨드 객체를 지우도록 할 수도 있고 저장해 둔 명령을 여러 번 수행하게 할 수도 있다.
## 커맨드 패턴 구현
### 첫 번째 커맨드 객체 만들기
- 커맨드 객체는 모두 같은 인터페이스를 구현해야하고 이 인터페이스에는 메소드는 한 개 밖에 없다.
  ``` java
  public interface Command{
    public void execute()
  }
  ```
- 조명을 켤 커맨드 클래스 구현
  ``` java
  public class LightOnCommand implements Command{
    Light light;
    public LightOnCommand(Light light){...} // 생성자에 커맨드 객체로 제어할 특정 조명의 정보가 전달된다.
    public void execute(){...} //light 객체의 on()메소드를 호출한다.
  }
  ```
- 리모컨에 커맨드 객체 사용
  ``` java
  public class SimpleRemoteController{
    Command slot; //이 슬롯으로 1개의 기기를 제어
    public SimpleRemoteController(){}
    public void setCommand(Command command){...} // 슬롯으로 제어할 명령을 설정하는 메소드
    public void buttonWasPressed(){...} // 버튼을 눌렀을 때 호출될 메소드
  }
  ```
## 커맨드 패턴의 정의
- 커맨드 패턴을 사용하면 요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있다.
  - 이러면 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있다.
- 명령으로 객체를 매개변수화한다는 것은 종업원이 여러 개의 주문서로 매개변수화되는 예에서 볼 수 있었다.
- 커맨드 객체를 사용하면 큐와 로그를 구현하거나 작업 취소를 할 수도 있고 메타 커맨드 패턴으로 여러 개의 명령을 매크로로 한 번에 실행할 수 있다.
## 리모컨 예제
- 리모컨의 각 버튼에 명령을 할당하면 리모컨이 인보커가 된다.
- 사용자가 그 버튼을 누르면 버튼에 맞는 커맨드 객체의 execute()메소드가 호출되고 리시버에서 특정 행동을 담당하는 메소드가 실행된다.
1. 버튼마다 명령(커맨드 객체)이 할당된다.
2. 사용자가 버튼을 누르면 해당 커맨드 객체의 execute()메소드가 호출된다.
3. execute()메소드는 리시버가 특정 작업을 처리하도록 지시한다.
- 구상 커맨드 객체를 람다 표현식으로 바꾸면 구상 커맨드 클래스를 모두 지울 수 있다.
## 커맨드 패턴 활용
- 커맨드로 컴퓨테이션의 한 부분(리시버와 일련의 행동)을 패키지로 묶어 일급 객체 형태로 전달할 수 있다.
  - 이렇게 하면 클라이언트 애플리케이션에서 커맨드 객체를 생성한 뒤 오랜 시간이 지나도 그 컴퓨테이션을 호출할 수 있고 다른 스레드에서도 호출할 수 있다.
  - 이를 활용하면 커맨드 패턴을 스케줄러나 스레드 풀, 작업 큐와 같은 다양한 작업에 적용할 수 있다.
- 어떤 어플은 모든 행동을 기록해두었다가 애플리케이션이 다운되었을 때 그 행동을 다시 호출해서 복구할 수 있어야 한다.
  - 커맨드 패턴을 사용하면 store(), load()메소드를 추가하여 이런 기능을 구현할 수 있다.
  - 자바에서는 이런 메소드를 객체 직렬화로 구현할 수도 있지만 직렬화와 관련된 제약 조건 때문에 그리 쉽지 않다.
